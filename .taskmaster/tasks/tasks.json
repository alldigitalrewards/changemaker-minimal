{
  "master": {
    "tasks": [
      {
        "id": 42,
        "title": "Database Schema Migration for RewardSTACK Integration",
        "description": "Add new fields and tables to support RewardSTACK integration, participant tracking, and reward issuance. This is a phase-1 task that establishes the foundational database schema for the RewardSTACK integration project.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Update Prisma schema to add fields for RewardSTACK configuration in Workspace, participant tracking in User, transaction tracking in RewardIssuance, catalog mapping in TenantSku, and necessary indexes. Use add-only migrations for backward compatibility. Encrypt sensitive fields using pgcrypto. Run migration using `pnpm prisma db push` and verify with staging DB. Tags: rewardstack, database, prisma, phase-1",
        "testStrategy": "Verify migration applies cleanly, all new fields exist, and indexes are created. Run Prisma migration tests and check for zero errors. Validate that the schema supports the RewardSTACK integration requirements for phase-1.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Schema Changes for RewardSTACK Integration",
            "description": "Specify all new fields and tables required for RewardSTACK integration, participant tracking, reward issuance, and catalog mapping for phase-1 implementation.",
            "dependencies": [],
            "details": "Work with stakeholders to define the exact fields for RewardSTACK configuration in Workspace, participant tracking in User, transaction tracking in RewardIssuance, and catalog mapping in TenantSku. Document field types, relationships, and which fields require encryption. Identify necessary indexes for performance. Focus on phase-1 requirements for the RewardSTACK integration project.",
            "status": "pending",
            "testStrategy": "Review schema design with engineering and product teams; validate against RewardSTACK integration requirements for phase-1."
          },
          {
            "id": 2,
            "title": "Update Prisma Schema with New Models and Fields",
            "description": "Implement the schema changes in the Prisma schema file, ensuring add-only modifications for backward compatibility and RewardSTACK integration support.",
            "dependencies": [
              1
            ],
            "details": "Edit `schema.prisma` to add new models, fields, and relations as specified for RewardSTACK integration. Use appropriate Prisma data types and attributes. Mark sensitive fields for later encryption. Ensure all changes are additive (no destructive changes). Include proper tagging for rewardstack and database components.",
            "status": "pending",
            "testStrategy": "Run `prisma validate` and `prisma format` to ensure schema correctness; peer review the schema changes for RewardSTACK compatibility."
          },
          {
            "id": 3,
            "title": "Create and Review Add-Only Migration Script",
            "description": "Generate and review the migration script to apply the schema changes using add-only operations for RewardSTACK database requirements.",
            "dependencies": [
              2
            ],
            "details": "Use `prisma migrate dev` or `prisma migrate diff` to generate the migration SQL for RewardSTACK integration. Ensure the script only adds tables, columns, and indexes. Manually review the SQL for safety and compliance with add-only policy. Verify compatibility with phase-1 requirements.",
            "status": "pending",
            "testStrategy": "Apply migration to a test database; verify no data loss or destructive changes; confirm all new fields and tables are present for RewardSTACK integration."
          },
          {
            "id": 4,
            "title": "Implement Encryption for Sensitive Fields Using pgcrypto",
            "description": "Set up encryption for sensitive RewardSTACK fields in the database using pgcrypto, updating the Prisma schema and migration as needed.",
            "dependencies": [
              3
            ],
            "details": "Identify sensitive fields (e.g., RewardSTACK API keys) and modify the migration script to use pgcrypto functions for encryption. Update Prisma schema to reflect encrypted fields. Ensure application code can read/write encrypted data for RewardSTACK integration. Focus on phase-1 security requirements.",
            "status": "pending",
            "testStrategy": "Insert and retrieve test data for encrypted RewardSTACK fields; verify encryption at rest in the database."
          },
          {
            "id": 5,
            "title": "Execute Migration and Validate on Staging Database",
            "description": "Run the migration using `pnpm prisma db push` on the staging database and verify all RewardSTACK integration changes, including indexes and encryption.",
            "dependencies": [
              4
            ],
            "details": "Apply the migration to the staging environment for RewardSTACK integration. Check that all new fields, tables, and indexes exist. Validate that sensitive fields are encrypted. Run integration and migration tests to confirm zero errors. Verify readiness for phase-1 RewardSTACK implementation.",
            "status": "pending",
            "testStrategy": "Automated and manual tests: check schema, run Prisma migration tests, verify encryption, and confirm application functionality for RewardSTACK integration phase-1."
          }
        ]
      },
      {
        "id": 43,
        "title": "Implement RewardSTACK Authentication Layer",
        "description": "Create JWT bearer token generation, caching, and refresh logic for RewardSTACK API.",
        "details": "Implement `generateBearerToken()` using `jsonwebtoken` (latest v9.x) or Web Crypto API. Cache token in memory, auto-refresh if expiring within 5 minutes. Implement error handling for 401 and configuration errors. Log all auth attempts for audit. Store encrypted API key in Workspace config.",
        "testStrategy": "Unit test token generation, expiry, refresh, and error handling. Simulate expired tokens and invalid API keys.",
        "priority": "high",
        "dependencies": [
          42
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement JWT Bearer Token Generation Logic",
            "description": "Develop the function to generate JWT bearer tokens using jsonwebtoken v9.x or Web Crypto API for RewardSTACK API authentication.",
            "dependencies": [],
            "details": "Use the jsonwebtoken library (v9.x) to create and sign JWT tokens with the required claims and expiration. Ensure the payload includes necessary fields such as issuer, subject, and expiry. Support both symmetric and asymmetric signing as needed. Validate configuration and handle key management securely.",
            "status": "pending",
            "testStrategy": "Unit test token generation with valid and invalid payloads, verify token structure and claims, and check compatibility with RewardSTACK API."
          },
          {
            "id": 2,
            "title": "Implement In-Memory Token Caching and Auto-Refresh Logic",
            "description": "Create logic to cache JWT tokens in memory and automatically refresh them if they are expiring within 5 minutes.",
            "dependencies": [
              1
            ],
            "details": "Store the generated JWT token in a memory cache. Monitor token expiry and trigger auto-refresh if the token is about to expire (within 5 minutes). Ensure thread safety and avoid race conditions during refresh. Provide a method to retrieve the current valid token for API requests.",
            "status": "pending",
            "testStrategy": "Simulate token expiry and verify auto-refresh triggers correctly. Test concurrent requests to ensure only one refresh occurs. Validate cache invalidation and token replacement."
          },
          {
            "id": 3,
            "title": "Implement Error Handling and Audit Logging for Authentication",
            "description": "Add robust error handling for 401 responses and configuration errors, and log all authentication attempts for auditing purposes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Detect and handle authentication errors such as invalid credentials, expired tokens, and misconfiguration. Log all authentication attempts, including successes and failures, with relevant metadata for audit trails. Ensure logs are structured and securely stored.",
            "status": "pending",
            "testStrategy": "Trigger error scenarios (401, config errors) and verify correct error handling and logging. Review audit logs for completeness and accuracy."
          },
          {
            "id": 4,
            "title": "Implement Secure Storage and Encryption of API Keys in Workspace Config",
            "description": "Store the API key securely in the workspace configuration, ensuring it is encrypted at rest and accessible only for authentication.",
            "dependencies": [],
            "details": "Integrate encryption for API keys before storing them in workspace config. Use a secure encryption algorithm and manage keys appropriately. Provide methods to retrieve and decrypt the API key only when needed for token generation. Document the encryption and access process.",
            "status": "pending",
            "testStrategy": "Test storing and retrieving encrypted API keys. Attempt unauthorized access and verify keys remain protected. Validate encryption and decryption logic."
          }
        ]
      },
      {
        "id": 44,
        "title": "Admin RewardSTACK Configuration UI",
        "description": "Build admin UI for configuring RewardSTACK integration, including environment, API key, program ID, and enable/disable toggle. Tags: rewardstack, ui, admin, phase-1",
        "status": "pending",
        "dependencies": [
          43
        ],
        "priority": "medium",
        "details": "Create React server component with tab navigation. Use password field for API key, dropdown for environment, and validation for required fields. Implement test connection button calling backend API. Display connection status, last test timestamp, and health indicator. Use latest Next.js and Tailwind CSS for UI. This is part of phase-1 implementation for RewardSTACK integration.",
        "testStrategy": "UI tests for form validation, connection test, enable/disable toggle, and error/success toasts.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design UI Form Layout and Implement Field Validation",
            "description": "Create the admin configuration form with fields for environment (dropdown), API key (password field), program ID, and enable/disable toggle. Add client-side and server-side validation for required fields.",
            "dependencies": [],
            "details": "Use React server components with Next.js and Tailwind CSS to build the form. Implement field validation using react-hook-form or zod for both client and server validation. Ensure the API key uses a password input and all fields have clear validation messages. Required fields must be enforced and errors shown inline.",
            "status": "pending",
            "testStrategy": "Write UI tests to verify required field validation, correct error messages, and form layout."
          },
          {
            "id": 2,
            "title": "Integrate Test Connection Button with Backend API",
            "description": "Add a 'Test Connection' button that calls the backend API to verify RewardSTACK credentials and program connectivity.",
            "dependencies": [
              1
            ],
            "details": "Implement the button to trigger a POST request to the backend test connection endpoint. Handle loading state and display results based on API response. Do not persist credentials during the test. Ensure the button is disabled if required fields are missing or invalid.",
            "status": "pending",
            "testStrategy": "Mock backend responses and test that the button triggers the API call, handles loading, and displays results appropriately."
          },
          {
            "id": 3,
            "title": "Display Connection Status, Last Test Timestamp, and Health Indicator",
            "description": "Show the current connection status, last successful test timestamp, and a visual health indicator in the UI.",
            "dependencies": [
              2
            ],
            "details": "After a test connection, update the UI to reflect the connection status (success/failure), show the last test time, and display a health indicator (e.g., colored icon or badge). Ensure this information updates in real time after each test.",
            "status": "pending",
            "testStrategy": "Test that status, timestamp, and health indicator update correctly after each test and persist across page reloads if applicable."
          },
          {
            "id": 4,
            "title": "Implement Error and Success Toast Notifications",
            "description": "Provide user feedback via toast notifications for form submission, test connection results, and validation errors.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Use a toast notification library or custom component to display error and success messages for all major user actions, including form submission, test connection, and validation failures. Ensure notifications are accessible and dismissible.",
            "status": "pending",
            "testStrategy": "Test that toasts appear for all relevant actions, display correct messages, and are accessible (screen reader, keyboard)."
          }
        ]
      },
      {
        "id": 45,
        "title": "API Route: Test RewardSTACK Connection",
        "description": "Create POST endpoint to test RewardSTACK credentials and program connectivity. Tags: rewardstack, api, testing, phase-1",
        "status": "pending",
        "dependencies": [
          43
        ],
        "priority": "medium",
        "details": "Implement POST `/api/workspaces/[slug]/rewardstack/test-connection` using Next.js API routes. Authenticate admin, generate JWT, call RewardSTACK `/api/2.0/programs/{programId}` endpoint, and return success/error. Do not persist credentials. This is part of phase-1 implementation for RewardSTACK integration.",
        "testStrategy": "API tests for valid/invalid credentials, error handling, and response schema.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Admin Authentication Middleware for API Route",
            "description": "Create middleware to authenticate admin users before allowing access to the RewardSTACK test connection endpoint.",
            "dependencies": [],
            "details": "Develop a middleware function for Next.js API routes that verifies the admin's authentication status, using JWT or session validation as appropriate. Ensure only authenticated admins can access the POST `/api/workspaces/[slug]/rewardstack/test-connection` endpoint. Integrate this middleware into the route handler.",
            "status": "pending",
            "testStrategy": "Send requests with and without valid admin credentials to verify access control. Confirm unauthorized requests are rejected with appropriate status codes."
          },
          {
            "id": 2,
            "title": "Generate JWT and Call RewardSTACK API Endpoint",
            "description": "Within the protected route, generate a JWT and use it to call the RewardSTACK `/api/2.0/programs/{programId}` endpoint to test connectivity.",
            "dependencies": [
              1
            ],
            "details": "After successful admin authentication, generate a JWT using the provided credentials. Use this JWT to make a POST request to the RewardSTACK API endpoint, passing the necessary headers and parameters. Do not persist any credentials. Capture the response for further processing.",
            "status": "pending",
            "testStrategy": "Mock RewardSTACK API responses for valid and invalid credentials. Verify that the JWT is generated and used correctly in the outbound request."
          },
          {
            "id": 3,
            "title": "Format API Response and Implement Error Handling",
            "description": "Format the API response to clearly indicate success or error, and handle all error scenarios robustly.",
            "dependencies": [
              2
            ],
            "details": "Process the response from the RewardSTACK API call. Return a structured JSON response indicating success or failure, including error messages and status codes as appropriate. Ensure all exceptions and error cases (e.g., network errors, invalid credentials) are handled gracefully and logged if needed.",
            "status": "pending",
            "testStrategy": "Test the endpoint with various scenarios (success, invalid credentials, network failure) and verify that the API returns the correct status codes and error messages."
          }
        ]
      },
      {
        "id": 46,
        "title": "API Route: Update RewardSTACK Configuration",
        "description": "Create PUT endpoint to update Workspace RewardSTACK config securely. Tags: rewardstack, api, config, phase-1",
        "status": "pending",
        "dependencies": [
          44
        ],
        "priority": "medium",
        "details": "Implement PUT `/api/workspaces/[slug]/rewardstack/config` with admin auth, field validation, API key encryption, and transactional DB update. Log configuration changes in ActivityEvent for audit. This is part of phase-1 implementation for RewardSTACK integration.",
        "testStrategy": "API tests for config update, encryption, audit logging, and error handling.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Admin Authentication and Input Validation for PUT Endpoint",
            "description": "Ensure only authorized admins can update RewardSTACK configuration and validate all input fields for correctness and completeness.",
            "dependencies": [],
            "details": "Add middleware to authenticate admin users for the PUT `/api/workspaces/[slug]/rewardstack/config` route. Implement schema validation for all incoming fields (e.g., environment, API key, program ID, enable/disable flag) using a validation library. Reject requests with invalid or missing data and return appropriate error responses.",
            "status": "pending",
            "testStrategy": "Unit and integration tests for authentication failures, missing/invalid fields, and correct error responses."
          },
          {
            "id": 2,
            "title": "Encrypt API Key and Securely Store Configuration Data",
            "description": "Encrypt the RewardSTACK API key before storing it in the database and ensure all sensitive fields are handled securely.",
            "dependencies": [
              1
            ],
            "details": "Use a strong encryption algorithm (e.g., AES-256) to encrypt the API key before saving it. Store the encrypted key and other configuration fields in the database. Ensure decryption is only possible in secure backend contexts and never expose raw keys in logs or responses.",
            "status": "pending",
            "testStrategy": "Unit tests for encryption/decryption logic and verification that plaintext keys are never persisted or logged."
          },
          {
            "id": 3,
            "title": "Implement Transactional Database Update Logic",
            "description": "Update the RewardSTACK configuration in the database using a transaction to ensure atomicity and prevent partial writes.",
            "dependencies": [
              2
            ],
            "details": "Wrap the configuration update logic in a database transaction. Ensure that all changes (including encrypted API key and other fields) are committed together, and roll back on any error. Handle concurrency and potential conflicts gracefully.",
            "status": "pending",
            "testStrategy": "Integration tests to simulate failures and verify that no partial updates occur; check rollback on error."
          },
          {
            "id": 4,
            "title": "Integrate Audit Logging for Configuration Changes",
            "description": "Log all configuration changes to the ActivityEvent system for audit and traceability.",
            "dependencies": [
              3
            ],
            "details": "After a successful transactional update, create an ActivityEvent entry capturing the admin user, timestamp, and details of the configuration change (excluding sensitive values). Ensure logs are immutable and accessible for audit purposes.",
            "status": "pending",
            "testStrategy": "Integration tests to verify that audit logs are created for every successful update and contain correct metadata."
          }
        ]
      },
      {
        "id": 47,
        "title": "Participant Sync Service for RewardSTACK",
        "description": "Implement automatic participant creation and update in RewardSTACK on first reward issuance. Tags: rewardstack, sync, api, phase-2",
        "status": "pending",
        "dependencies": [
          46
        ],
        "priority": "high",
        "details": "Create `lib/rewardstack/participants.ts` with functions for create, update, and get participant using RewardSTACK API v2.2. Handle duplicate, validation, and auth errors. Integrate with `issueReward()` for lazy sync. Use Prisma `$transaction()` for atomicity. This is a phase-2 feature focusing on RewardSTACK sync and API integration.",
        "testStrategy": "Unit tests for participant creation, duplicate handling, error logging, and sync retry logic. Include tests for rewardstack API integration scenarios.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement RewardSTACK Participant API Integration (Create, Update, Get)",
            "description": "Develop functions to create, update, and retrieve participants using RewardSTACK API v2.2.",
            "dependencies": [],
            "details": "Create `lib/rewardstack/participants.ts` with async functions for participant creation, update, and retrieval. Use the RewardSTACK API v2.2 endpoints, handle authentication, and ensure correct request/response mapping. Document function signatures and expected payloads.",
            "status": "pending",
            "testStrategy": "Unit tests for each API function using mocked HTTP responses."
          },
          {
            "id": 2,
            "title": "Implement Error Handling and Duplicate Participant Logic",
            "description": "Add logic to handle duplicate, validation, and authentication errors from the RewardSTACK API.",
            "dependencies": [
              1
            ],
            "details": "Extend API functions to detect and handle duplicate participant errors (e.g., by checking error codes or messages), validation failures, and authentication issues. Implement retry or fallback logic as appropriate. Ensure errors are logged and surfaced for debugging.",
            "status": "pending",
            "testStrategy": "Unit tests simulating API error responses for duplicates, validation, and auth failures."
          },
          {
            "id": 3,
            "title": "Integrate Participant Sync with Reward Issuance Flow",
            "description": "Connect participant sync logic to the `issueReward()` function for lazy creation/update on first reward issuance.",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify `issueReward()` to check for participant existence and trigger create/update as needed before issuing a reward. Ensure the sync is performed only when necessary (lazy sync) and does not block reward issuance unnecessarily.",
            "status": "pending",
            "testStrategy": "Integration tests for reward issuance with and without existing participants."
          },
          {
            "id": 4,
            "title": "Ensure Atomic Operations with Prisma Transactions",
            "description": "Wrap participant sync and reward issuance in a Prisma `$transaction()` to guarantee atomicity.",
            "dependencies": [
              3
            ],
            "details": "Refactor the reward issuance and participant sync logic to execute within a single Prisma `$transaction()`. Ensure that both DB updates and external API calls are coordinated to prevent partial updates or inconsistent state.",
            "status": "pending",
            "testStrategy": "Unit and integration tests to verify rollback on failure and atomicity of operations."
          },
          {
            "id": 5,
            "title": "Develop Unit and Integration Tests for Participant Sync Scenarios",
            "description": "Write comprehensive tests covering participant creation, duplicate handling, error logging, and sync retry logic.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement unit tests for all participant API functions and error scenarios. Add integration tests for the full sync flow, including reward issuance and transaction atomicity. Cover edge cases such as retries, partial failures, and concurrent sync attempts.",
            "status": "pending",
            "testStrategy": "Automated test suite with coverage for all sync scenarios and error cases."
          }
        ]
      },
      {
        "id": 48,
        "title": "Enhance Reward Issuance Logic for Points via RewardSTACK",
        "description": "Issue point rewards using RewardSTACK adjustments API with retry and error handling. This is part of phase-2 implementation for enhanced reward processing capabilities.",
        "status": "pending",
        "dependencies": [
          47
        ],
        "priority": "high",
        "details": "Implement `issuePointReward()` and `issuePointRewardWithRetry()` in `lib/rewardstack/rewards.ts`. Use exponential backoff, 30s timeout, and error classification. Update `issueReward()` to call these for point rewards. Store external transaction ID and response in RewardIssuance. Tags: rewardstack, rewards, points, phase-2",
        "testStrategy": "Integration tests for successful issuance, retries, error scenarios, and DB record creation.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Point Reward Issuance with Error Classification and Exponential Backoff",
            "description": "Develop the core logic for issuing point rewards via RewardSTACK adjustments API, including error classification and exponential backoff retry mechanism.",
            "dependencies": [],
            "details": "Create `issuePointReward()` and `issuePointRewardWithRetry()` functions in `lib/rewardstack/rewards.ts`. Integrate with RewardSTACK adjustments API using the 'credit' adjustment type for points. Implement error classification to distinguish between transient and permanent errors. Use exponential backoff for retries, with a maximum timeout of 30 seconds per attempt. This implementation supports the phase-2 reward processing enhancement.",
            "status": "pending",
            "testStrategy": "Unit tests for error classification, backoff timing, and API request structure. Mock API responses for transient and permanent errors."
          },
          {
            "id": 2,
            "title": "Update Reward Issuance Flow to Use Enhanced Point Logic",
            "description": "Refactor the main reward issuance function to utilize the new point reward logic for point-type rewards.",
            "dependencies": [
              1
            ],
            "details": "Modify `issueReward()` to call `issuePointRewardWithRetry()` when issuing point rewards. Ensure correct routing based on reward type. Maintain compatibility with existing SKU and monetary reward logic. This update is part of the phase-2 reward system improvements.",
            "status": "pending",
            "testStrategy": "Integration tests to verify correct function calls for point rewards and regression tests for other reward types."
          },
          {
            "id": 3,
            "title": "Store External Transaction ID and API Response in RewardIssuance Record",
            "description": "Persist the external transaction ID and full API response from RewardSTACK in the RewardIssuance database record for traceability.",
            "dependencies": [
              2
            ],
            "details": "Update the RewardIssuance model and database logic to store the external transaction ID and relevant response data after successful or failed point reward issuance. Ensure data integrity and error handling for failed writes. This enhancement supports better tracking and debugging capabilities in phase-2.",
            "status": "pending",
            "testStrategy": "Database tests to confirm correct storage of transaction ID and response. Integration tests for end-to-end issuance and record creation."
          }
        ]
      },
      {
        "id": 49,
        "title": "Enhance Reward Issuance Logic for SKU and Monetary Rewards",
        "description": "Issue SKU and monetary rewards via RewardSTACK transactions API with validation and retry logic. This is part of phase-2 implementation for enhanced reward processing capabilities.",
        "status": "pending",
        "dependencies": [
          48
        ],
        "priority": "high",
        "details": "Implement `issueSkuReward()` and `issueSkuRewardWithRetry()` in `lib/rewardstack/rewards.ts`. Validate SKU before transaction, handle participant sync, and error scenarios. Update `issueReward()` for SKU/monetary types. Store transaction details in RewardIssuance. Tags: rewardstack, rewards, sku, phase-2",
        "testStrategy": "Integration tests for SKU validation, transaction flow, retries, and DB updates.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SKU and Monetary Reward Issuance with Validation",
            "description": "Develop functions to issue SKU and monetary rewards via the RewardSTACK transactions API, ensuring SKU validation and participant synchronization before transaction.",
            "dependencies": [],
            "details": "Implement `issueSkuReward()` in `lib/rewardstack/rewards.ts` to validate SKU existence and eligibility before initiating the transaction. Ensure participant data is synchronized with RewardSTACK. Handle pre-transaction validation errors and return appropriate error responses.",
            "status": "pending",
            "testStrategy": "Unit and integration tests for SKU validation, participant sync, and error handling before transaction."
          },
          {
            "id": 2,
            "title": "Add Retry Logic and Error Handling for Reward Issuance",
            "description": "Enhance reward issuance with robust retry logic for transient failures and comprehensive error handling for both SKU and monetary rewards.",
            "dependencies": [
              1
            ],
            "details": "Implement `issueSkuRewardWithRetry()` to wrap the issuance logic with retry mechanisms (e.g., exponential backoff) for network or API errors. Classify errors as retryable or non-retryable. Ensure that all error scenarios are logged and surfaced appropriately.",
            "status": "pending",
            "testStrategy": "Integration tests simulating transient and permanent errors, verifying retry attempts, and correct error classification."
          },
          {
            "id": 3,
            "title": "Update Reward Issuance Flow and Persist Transaction Details",
            "description": "Update the main `issueReward()` function to support SKU and monetary reward types, and persist all transaction details in the RewardIssuance database.",
            "dependencies": [
              2
            ],
            "details": "Modify `issueReward()` to route SKU and monetary rewards to the new issuance logic. Ensure transaction responses, including external transaction IDs and statuses, are stored in the RewardIssuance table for auditing and reconciliation.",
            "status": "pending",
            "testStrategy": "Integration tests for end-to-end reward issuance, database record creation, and data integrity checks."
          }
        ]
      },
      {
        "id": 50,
        "title": "RewardSTACK Webhook Handler",
        "description": "Create webhook endpoint to process RewardSTACK fulfillment events and update reward status. Tags: rewardstack, webhooks, api, phase-2",
        "status": "pending",
        "dependencies": [
          49
        ],
        "priority": "high",
        "details": "Implement POST `/api/webhooks/rewardstack` route. Verify webhook signature, handle events (`reward.fulfilled`, `reward.failed`, `reward.cancelled`), update RewardIssuance status, log ActivityEvent, and return 200 OK. Use latest crypto libraries for signature verification. This is part of phase-2 implementation for RewardSTACK integration.",
        "testStrategy": "API tests for webhook signature, event handling, status updates, and error logging.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Webhook Endpoint and Signature Verification",
            "description": "Create the POST /api/webhooks/rewardstack endpoint and verify incoming webhook signatures using the latest crypto libraries.",
            "dependencies": [],
            "details": "Set up the Express (or relevant framework) route for POST /api/webhooks/rewardstack. Parse the raw request body as required for signature verification. Use the latest crypto library (e.g., Node.js crypto) to compute and verify the HMAC signature against the provided header. Reject requests with invalid signatures and return 401 Unauthorized.",
            "status": "pending",
            "testStrategy": "Send test requests with valid and invalid signatures to ensure only valid requests are processed and others are rejected with 401."
          },
          {
            "id": 2,
            "title": "Parse and Handle RewardSTACK Event Types",
            "description": "Extract and process event types from the webhook payload, supporting 'reward.fulfilled', 'reward.failed', and 'reward.cancelled'.",
            "dependencies": [
              1
            ],
            "details": "After signature verification, parse the JSON payload and determine the event type. Implement logic to route each event type ('reward.fulfilled', 'reward.failed', 'reward.cancelled') to the appropriate handler function for further processing.",
            "status": "pending",
            "testStrategy": "Send sample payloads for each event type and verify correct handler invocation and branching."
          },
          {
            "id": 3,
            "title": "Update RewardIssuance Status and Log ActivityEvent",
            "description": "Update the RewardIssuance record status based on the event and log an ActivityEvent for auditing.",
            "dependencies": [
              2
            ],
            "details": "For each event, update the corresponding RewardIssuance record in the database to reflect the new status. Create and persist an ActivityEvent entry with relevant details for audit purposes. Ensure idempotency by checking if the status has already been updated.",
            "status": "pending",
            "testStrategy": "Verify that database records are updated correctly and ActivityEvent logs are created for each event, including repeated (idempotent) requests."
          },
          {
            "id": 4,
            "title": "Implement Error Handling, Response Logic, and API Tests",
            "description": "Handle errors gracefully, ensure correct HTTP responses, and implement comprehensive API tests for all event types and error scenarios.",
            "dependencies": [
              3
            ],
            "details": "Return 200 OK for successful processing, 401 for invalid signatures, and 500 for internal errors. Log errors for monitoring. Write automated API tests covering valid events, invalid signatures, malformed payloads, and database failures.",
            "status": "pending",
            "testStrategy": "Run automated tests to confirm correct responses and error handling for all event types and failure scenarios."
          }
        ]
      },
      {
        "id": 51,
        "title": "Admin Reward Management and Reconciliation Dashboard",
        "description": "Build admin UI for monitoring, filtering, and retrying reward issuances. Tags: rewardstack, admin, dashboard, ui, phase-2",
        "status": "pending",
        "dependencies": [
          50
        ],
        "priority": "medium",
        "details": "Create React server component for `/admin/rewards` page. Display reward issuance table with filters, manual/bulk retry buttons, error details, and CSV export. Integrate with retry API route. Use Prisma for efficient queries and indexes. This is part of phase-2 implementation for RewardSTACK integration, providing comprehensive admin tools for reward management and reconciliation.",
        "testStrategy": "UI tests for filtering, retry actions, error display, and CSV export.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Reward Issuance Table with Filters and Pagination",
            "description": "Create a React server component to display a table of reward issuances with filtering and pagination capabilities.",
            "dependencies": [],
            "details": "Design and build the `/admin/rewards` page to show a paginated table of reward issuances. Add filter controls for status, date range, and error type. Use Prisma for efficient data queries and indexes to support fast filtering and pagination.",
            "status": "pending",
            "testStrategy": "UI tests for table rendering, filter functionality, and pagination controls."
          },
          {
            "id": 2,
            "title": "Integrate Manual and Bulk Retry Functionality",
            "description": "Enable admins to manually retry individual or multiple failed reward issuances directly from the dashboard.",
            "dependencies": [
              1
            ],
            "details": "Add retry buttons to each row and bulk selection controls. Connect these actions to the retry API route. Ensure UI feedback for success/failure and update table state after retry attempts.",
            "status": "pending",
            "testStrategy": "UI and integration tests for retry actions, including error handling and state updates."
          },
          {
            "id": 3,
            "title": "Display Error Details and Status Indicators",
            "description": "Show detailed error messages and status indicators for each reward issuance in the table.",
            "dependencies": [
              1
            ],
            "details": "Extend table rows to include error details, status badges, and tooltips. Ensure error information is fetched efficiently and displayed clearly for admin troubleshooting.",
            "status": "pending",
            "testStrategy": "UI tests for error detail rendering, status badge accuracy, and tooltip accessibility."
          },
          {
            "id": 4,
            "title": "Implement CSV Export Functionality",
            "description": "Allow admins to export filtered reward issuance data as a CSV file.",
            "dependencies": [
              1
            ],
            "details": "Add an export button that generates a CSV file of the currently filtered table data. Ensure proper formatting and handle large dataset exports efficiently.",
            "status": "pending",
            "testStrategy": "Functional tests for CSV export accuracy, formatting, and performance with large datasets."
          },
          {
            "id": 5,
            "title": "Optimize Performance for Large Datasets and Ensure UI/UX Accessibility",
            "description": "Improve dashboard performance for large reward datasets and verify UI/UX accessibility compliance.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement query optimizations, server-side pagination, and lazy loading. Conduct accessibility checks (ARIA, keyboard navigation, color contrast) and refine UI/UX for admin workflows.",
            "status": "pending",
            "testStrategy": "Performance benchmarks, accessibility audits, and usability testing."
          }
        ]
      },
      {
        "id": 52,
        "title": "API Route: Manual Retry for Failed Rewards",
        "description": "Create POST endpoint to manually retry failed reward issuances. Tags: rewardstack, admin, api, retry, phase-2",
        "status": "pending",
        "dependencies": [
          51
        ],
        "priority": "medium",
        "details": "Implement POST `/api/workspaces/[slug]/rewards/[id]/retry` with admin auth. Call appropriate reward issuance function based on type, update status, and return updated record. Handle error scenarios and log retries. This is part of phase-2 implementation for RewardSTACK integration, providing API support for manual retry functionality in the admin dashboard.",
        "testStrategy": "API tests for retry logic, status updates, and error handling.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Admin Authentication and Input Validation for Retry Endpoint",
            "description": "Ensure only authorized admin users can access the manual retry endpoint and validate all input parameters for correctness.",
            "dependencies": [],
            "details": "Add middleware to the POST `/api/workspaces/[slug]/rewards/[id]/retry` route to enforce admin authentication. Validate the workspace slug and reward ID, ensuring they exist and are in the correct format. Return appropriate error responses for unauthorized or invalid requests.",
            "status": "pending",
            "testStrategy": "Unit and integration tests for authentication failures, invalid input, and successful validation."
          },
          {
            "id": 2,
            "title": "Implement Reward Issuance Retry Logic by Reward Type with Status Update and Error Handling",
            "description": "Invoke the correct reward issuance function based on reward type, ensure idempotency, update status, and handle errors robustly.",
            "dependencies": [
              1
            ],
            "details": "Based on the reward type, call the appropriate issuance function. Ensure the retry is idempotent to prevent duplicate rewards. Update the reward status according to the outcome (success, still failed, or permanently failed). Handle and return errors clearly, including edge cases such as already-processed rewards.",
            "status": "pending",
            "testStrategy": "Integration tests for each reward type, simulating both successful and failed retries, and verifying correct status transitions and error responses."
          },
          {
            "id": 3,
            "title": "Implement Audit Logging and API Tests for Manual Retry Scenarios",
            "description": "Log all manual retry attempts with relevant metadata and create comprehensive API tests covering all retry scenarios.",
            "dependencies": [
              2
            ],
            "details": "Record each retry attempt in an audit log, including admin user, timestamp, reward ID, outcome, and error details if any. Develop API tests for successful retries, repeated failures, invalid requests, and audit log verification.",
            "status": "pending",
            "testStrategy": "Automated tests to verify audit log entries for each retry scenario and end-to-end API tests for all manual retry flows."
          }
        ]
      },
      {
        "id": 53,
        "title": "Participant Reward Catalog SSO Integration",
        "description": "Enable participants to access RewardSTACK catalog via SSO token. Tags: rewardstack, participant, sso, phase-3",
        "status": "pending",
        "dependencies": [
          49
        ],
        "priority": "medium",
        "details": "Implement `/api/rewardstack/sso` endpoint to generate SSO token and redirect URL. Add UI button to participant dashboard to open catalog. Handle token expiry and error scenarios. Use latest fetch and JWT libraries. This is a phase-3 feature focusing on participant-facing catalog access through SSO integration.",
        "testStrategy": "E2E tests for SSO flow, token generation, redirect, and error handling.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement /api/rewardstack/sso Endpoint for SSO Token Generation",
            "description": "Develop the backend API endpoint to generate a JWT SSO token and provide the redirect URL for RewardSTACK catalog access.",
            "dependencies": [],
            "details": "Create the `/api/rewardstack/sso` endpoint using the latest fetch and JWT libraries. Ensure the endpoint validates participant identity, generates a secure SSO token, and returns the correct redirect URL for the RewardSTACK catalog. Handle token expiry and error scenarios in the response.",
            "status": "pending",
            "testStrategy": "Unit and integration tests for token generation, expiry handling, and error responses."
          },
          {
            "id": 2,
            "title": "Add Catalog Access Button to Participant Dashboard UI",
            "description": "Integrate a UI button on the participant dashboard that initiates the SSO flow and opens the RewardSTACK catalog.",
            "dependencies": [
              1
            ],
            "details": "Update the participant dashboard React component to include a 'View Catalog' button. On click, call the `/api/rewardstack/sso` endpoint, handle loading and error states, and redirect the user to the catalog using the provided URL. Ensure accessibility and responsive design.",
            "status": "pending",
            "testStrategy": "UI tests for button visibility, click behavior, redirect flow, and error display."
          },
          {
            "id": 3,
            "title": "Implement Token Expiry and Error Handling Logic",
            "description": "Ensure robust handling of SSO token expiry and error scenarios throughout the integration.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add logic to detect expired or invalid tokens both on the backend and frontend. Display clear error messages to participants and provide retry options. Log errors for monitoring and debugging. Test with various expiry and failure cases.",
            "status": "pending",
            "testStrategy": "E2E tests simulating token expiry, invalid tokens, and error conditions; verify user messaging and system logging."
          }
        ]
      },
      {
        "id": 54,
        "title": "Participant Dashboard Reward History and Catalog Access",
        "description": "Display participant point balance, recent rewards, and catalog access. Tags: rewardstack, participant, dashboard, ui, phase-3",
        "status": "pending",
        "dependencies": [
          53
        ],
        "priority": "low",
        "details": "Create React client component for reward history and catalog button. Fetch point balance from RewardSTACK, show last 10 rewards, and integrate SSO access. Use SWR or React Query for caching. This is a phase-3 feature focusing on participant-facing dashboard UI components with RewardSTACK integration.",
        "testStrategy": "UI tests for balance display, reward history, and catalog access. Include tests for RewardSTACK integration and dashboard component functionality.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Point Balance and Recent Rewards Display Component",
            "description": "Create a React component to show the participant's current point balance and the last 10 rewards earned.",
            "dependencies": [],
            "details": "Use SWR or React Query to fetch the point balance and recent rewards from RewardSTACK. Design the UI to clearly display the balance and a list of the 10 most recent rewards. Ensure loading and error states are handled gracefully.",
            "status": "pending",
            "testStrategy": "Write unit and UI tests to verify correct data fetching, rendering of balance and rewards, and proper handling of loading and error states."
          },
          {
            "id": 2,
            "title": "Integrate Reward Catalog Access with SSO",
            "description": "Add a button to the dashboard that allows participants to access the RewardSTACK catalog via SSO.",
            "dependencies": [
              1
            ],
            "details": "Implement a button that triggers the SSO flow by calling the appropriate API endpoint to obtain an SSO token and redirect URL. Handle token expiry and error scenarios. Ensure the button is only enabled when the participant is eligible.",
            "status": "pending",
            "testStrategy": "Perform E2E tests to confirm the SSO flow works, including token retrieval, redirect, and error handling."
          },
          {
            "id": 3,
            "title": "Integrate and Cache Data Fetching with SWR or React Query",
            "description": "Set up SWR or React Query for efficient data fetching and caching of reward history and point balance.",
            "dependencies": [
              1,
              2
            ],
            "details": "Configure SWR or React Query hooks for all relevant API calls. Ensure data is cached and revalidated appropriately to optimize performance and user experience. Document the caching strategy and test cache invalidation scenarios.",
            "status": "pending",
            "testStrategy": "Test cache behavior, including cache hits, misses, and revalidation. Verify that UI updates correctly when data changes."
          }
        ]
      },
      {
        "id": 55,
        "title": "Background Job: Automatic Retry for Failed Rewards",
        "description": "Implement scheduled job to auto-retry failed rewards up to 3 times. Tags: rewardstack, jobs, retry, phase-3",
        "status": "pending",
        "dependencies": [
          52
        ],
        "priority": "medium",
        "details": "Create cron job using Vercel Cron or similar scheduler. Query failed rewards, retry issuance, update status and retry count, and send admin alerts for exhausted retries. Use batch processing and delay to avoid rate limits. This is part of phase-3 implementation for RewardSTACK integration, providing automated recovery for failed reward issuances.",
        "testStrategy": "Unit and integration tests for job execution, retry logic, and alerting.",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Scheduled Cron Job for Automatic Retry",
            "description": "Set up a scheduled background job using Vercel Cron or a similar scheduler to trigger the automatic retry process for failed rewards.",
            "dependencies": [],
            "details": "Create or update the vercel.json file to define a cron job with the desired schedule (e.g., every hour). Implement an API route (e.g., /api/cron/retry-failed-rewards) that will be invoked by the cron job. Ensure the route is only accessible by the scheduler and not exposed publicly. Deploy the configuration to production so the job runs automatically.",
            "status": "pending",
            "testStrategy": "Verify the cron job triggers the API route at the scheduled interval by checking logs and monitoring invocations."
          },
          {
            "id": 2,
            "title": "Implement Batch Retry Logic for Failed Rewards",
            "description": "Develop the logic to query failed rewards, attempt re-issuance, update status and retry count, and handle exhausted retries within the scheduled job.",
            "dependencies": [
              1
            ],
            "details": "Within the cron-triggered function, query the database for rewards with failed status and retry count less than 3. Process rewards in batches to avoid rate limits, introducing delays as needed. For each reward, attempt re-issuance, update the status and increment the retry count. If the retry count reaches 3, mark as exhausted and prepare for admin alerting.",
            "status": "pending",
            "testStrategy": "Unit and integration tests for batch processing, retry logic, status updates, and handling of exhausted retries."
          },
          {
            "id": 3,
            "title": "Send Admin Alerts for Exhausted Reward Retries",
            "description": "Notify administrators when a reward has exhausted all automatic retry attempts without success.",
            "dependencies": [
              2
            ],
            "details": "Integrate alerting logic into the batch retry process. When a reward reaches the maximum retry count without success, trigger an admin notification (e.g., email or Slack alert) with relevant reward details. Ensure alerts are sent only once per exhausted reward.",
            "status": "pending",
            "testStrategy": "Simulate exhausted retries in test environment and verify that admin alerts are sent correctly and only once per reward."
          }
        ]
      },
      {
        "id": 56,
        "title": "Performance Optimization: Batch Participant Sync and Catalog Caching",
        "description": "Optimize participant sync and catalog queries for large datasets. Tags: rewardstack, performance, caching, phase-3",
        "status": "pending",
        "dependencies": [
          47
        ],
        "priority": "low",
        "details": "Implement batch sync in `lib/rewardstack/participants.ts` for bulk enrollment. Add catalog caching in `lib/rewardstack/catalog.ts` with 1-hour TTL. Verify DB indexes for reward queries. This is a phase-3 performance optimization task focusing on RewardSTACK integration efficiency and caching strategies.",
        "testStrategy": "Performance tests for batch sync, cache hit/miss, and query speed. Include load testing and performance profiling to validate optimization improvements.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Batch Participant Sync in participants.ts",
            "description": "Refactor participant synchronization logic to support efficient batch processing for bulk enrollment scenarios.",
            "dependencies": [],
            "details": "Update lib/rewardstack/participants.ts to process participant enrollments in batches rather than individually. Ensure the batch size is configurable and optimize database writes to minimize transaction overhead. Handle error aggregation and partial failures gracefully to avoid data loss.",
            "status": "pending",
            "testStrategy": "Run performance benchmarks comparing single vs. batch sync. Validate correctness with large datasets and simulate partial failures to ensure robust error handling."
          },
          {
            "id": 2,
            "title": "Add Catalog Caching with 1-Hour TTL in catalog.ts",
            "description": "Introduce a caching layer for catalog queries to reduce database load and improve response times.",
            "dependencies": [],
            "details": "Implement caching in lib/rewardstack/catalog.ts using an in-memory or distributed cache (e.g., Redis). Set cache entries to expire after 1 hour (TTL). Ensure cache invalidation on catalog updates and provide fallbacks for cache misses.",
            "status": "pending",
            "testStrategy": "Measure cache hit/miss rates and response times before and after caching. Test cache invalidation logic by updating the catalog and verifying cache refresh."
          },
          {
            "id": 3,
            "title": "Verify and Optimize Database Indexes for Reward Queries",
            "description": "Review and optimize database indexes to ensure efficient reward-related queries, especially under high load.",
            "dependencies": [],
            "details": "Analyze query patterns in reward-related operations. Use database tools to identify slow queries and missing indexes. Add or adjust indexes as needed to optimize performance, and document any schema changes.",
            "status": "pending",
            "testStrategy": "Profile query execution plans before and after index changes. Use load testing to confirm improved query performance and monitor for any regressions."
          }
        ]
      },
      {
        "id": 57,
        "title": "Documentation: RewardSTACK Integration and Troubleshooting Guides",
        "description": "Write comprehensive guides for API integration, troubleshooting, and admin operations. Tags: rewardstack, docs, phase-3",
        "status": "pending",
        "dependencies": [
          55
        ],
        "priority": "low",
        "details": "Create markdown docs covering authentication, endpoints, error codes, rate limits, setup, failed reward recovery, and monitoring. Include runbooks for support and admin teams. This is part of phase-3 implementation for RewardSTACK integration.",
        "testStrategy": "Peer review documentation for completeness and clarity.",
        "subtasks": [
          {
            "id": 1,
            "title": "Draft RewardSTACK API Integration Guide",
            "description": "Create a detailed markdown guide covering RewardSTACK API integration, including authentication, endpoints, setup, and rate limits.",
            "dependencies": [],
            "details": "Document the process for obtaining API credentials, authenticating requests, and integrating with key RewardSTACK endpoints. Include sections on endpoint structure, required headers, example requests/responses, rate limiting, and initial setup steps. Reference official RewardSTACK API documentation for accuracy.",
            "status": "pending",
            "testStrategy": "Peer review for technical accuracy and completeness; validate steps with a test integration."
          },
          {
            "id": 2,
            "title": "Develop RewardSTACK Troubleshooting and Error Handling Guide",
            "description": "Write a markdown guide focused on troubleshooting common integration issues, error codes, and failed reward recovery.",
            "dependencies": [
              1
            ],
            "details": "List common API errors, their meanings, and recommended resolutions. Provide a section on handling failed reward issuance and recovery procedures. Include troubleshooting steps for authentication failures, endpoint errors, and rate limit breaches. Add example error messages and diagnostic checklists.",
            "status": "pending",
            "testStrategy": "Review by support engineers; test troubleshooting steps against known failure scenarios."
          },
          {
            "id": 3,
            "title": "Create RewardSTACK Admin Operations and Monitoring Runbooks",
            "description": "Produce markdown runbooks for support and admin teams covering monitoring, configuration, and operational procedures.",
            "dependencies": [
              1,
              2
            ],
            "details": "Document admin workflows for configuring RewardSTACK integration, monitoring reward delivery, and responding to incidents. Include instructions for using admin tools, reviewing logs, and escalating issues. Provide operational checklists and monitoring best practices.",
            "status": "pending",
            "testStrategy": "Walkthrough by admin/support staff; validate clarity and usability in simulated operations."
          }
        ]
      },
      {
        "id": 58,
        "title": "Admin Dashboard Reward Stats and Alerts",
        "description": "Add widgets for reward issuance stats, failed rewards alerts, and recent activity. Tags: rewardstack, admin, dashboard, stats, phase-3",
        "status": "pending",
        "dependencies": [
          51
        ],
        "priority": "low",
        "details": "Enhance `/admin/dashboard` with widgets showing total issued, success/failure rates, top reward types, failed reward count, and recent activity. Use Prisma groupBy and efficient queries. This is a phase-3 feature focusing on admin dashboard analytics and monitoring capabilities for the RewardSTACK integration.",
        "testStrategy": "UI and integration tests for widget accuracy and performance. Include tests for RewardSTACK data integration and dashboard component functionality.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Reward Stats Widget (Totals, Rates, Top Types)",
            "description": "Develop a dashboard widget to display total rewards issued, success/failure rates, and top reward types using efficient backend aggregation.",
            "dependencies": [],
            "details": "Use Prisma's groupBy and aggregate functions to efficiently compute total rewards issued, calculate success and failure rates, and identify the top reward types. Design a clear UI widget for the admin dashboard to visualize these metrics. Ensure queries are optimized for performance and real-time accuracy.",
            "status": "pending",
            "testStrategy": "Write unit and integration tests to verify correct aggregation and display of totals, rates, and top types. Use mock data to simulate various reward issuance scenarios."
          },
          {
            "id": 2,
            "title": "Develop Failed Rewards Alert Logic and Widget",
            "description": "Create logic and a dashboard alert widget to highlight failed reward issuances and their count.",
            "dependencies": [
              1
            ],
            "details": "Implement backend logic to detect and count failed reward issuances using Prisma queries. Build a UI alert widget that displays the current failed reward count and optionally provides drill-down details. Ensure the alert updates in near real-time and is visually distinct for admin attention.",
            "status": "pending",
            "testStrategy": "Test alert triggering with simulated failed rewards. Verify the alert count matches backend data and updates correctly when failures occur or are resolved."
          },
          {
            "id": 3,
            "title": "Build Recent Activity Feed Widget with Efficient Querying",
            "description": "Add a recent activity feed widget to the admin dashboard, showing the latest reward-related events.",
            "dependencies": [
              1
            ],
            "details": "Query recent reward issuance and status change events using efficient pagination and sorting. Display the most recent activities in a feed-style widget, including timestamps and key details. Optimize queries to minimize load and ensure up-to-date information.",
            "status": "pending",
            "testStrategy": "Test feed accuracy and ordering with various activity scenarios. Use integration tests to ensure new events appear promptly and the feed handles large volumes efficiently."
          }
        ]
      },
      {
        "id": 59,
        "title": "Comprehensive Integration and E2E Testing",
        "description": "Write and execute tests for all RewardSTACK flows, error scenarios, and UI components. Tags: rewardstack, testing, e2e, phase-4",
        "status": "pending",
        "dependencies": [
          54,
          55,
          58
        ],
        "priority": "high",
        "details": "Implement unit, integration, and E2E tests for participant sync, reward issuance, webhook handling, SSO, admin dashboard, and retry logic. Use Jest (v29+) and Playwright for E2E. Achieve >90% coverage. This is part of phase-4 implementation for RewardSTACK integration.",
        "testStrategy": "Run full test suite, measure coverage, and validate all success/failure paths.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement Integration Test Suites for RewardSTACK Flows",
            "description": "Develop automated integration test suites covering all major RewardSTACK flows, including participant sync, reward issuance, webhook handling, SSO, admin dashboard, and retry logic.",
            "dependencies": [],
            "details": "Identify all module interactions and interfaces. Use Jest (v29+) to write integration tests that simulate real-world data and cover both positive and negative scenarios. Ensure tests validate data flow and error handling between components. Organize tests into logical suites for maintainability.",
            "status": "pending",
            "testStrategy": "Run integration test suites in CI, verify all flows and error paths, and review logs for failures or unexpected behaviors."
          },
          {
            "id": 2,
            "title": "Develop and Execute End-to-End (E2E) Test Scenarios Using Playwright",
            "description": "Create comprehensive E2E test cases that simulate user journeys and system workflows across the RewardSTACK UI and backend, validating both success and failure scenarios.",
            "dependencies": [
              1
            ],
            "details": "Use Playwright to automate browser-based tests for participant sync, reward issuance, webhook events, SSO, admin dashboard, and retry logic. Include edge cases, error handling, and UI validation. Ensure tests run in an environment closely matching production.",
            "status": "pending",
            "testStrategy": "Automate E2E test execution in CI, monitor for regressions, and validate that all critical user and system flows function as expected."
          },
          {
            "id": 3,
            "title": "Measure Coverage and Validate Test Effectiveness",
            "description": "Assess test coverage for integration and E2E suites, aiming for over 90% coverage, and validate that all critical paths and error scenarios are exercised.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use coverage tools with Jest and Playwright to measure code and scenario coverage. Review untested areas, add missing tests, and document results. Re-run tests after bug fixes or updates to ensure continued coverage and reliability.",
            "status": "pending",
            "testStrategy": "Generate and review coverage reports, ensure all modules and flows are tested, and manually inspect critical paths not covered by automation."
          }
        ]
      },
      {
        "id": 60,
        "title": "Production Deployment and Rollback Plan",
        "description": "Deploy RewardSTACK integration to production with rollback and monitoring. Tags: rewardstack, deployment, production, phase-4",
        "status": "pending",
        "dependencies": [
          59
        ],
        "priority": "high",
        "details": "Run full test suite, apply migrations, deploy backend, configure webhook, monitor logs, and verify email delivery. Document rollback steps and enable feature flag for manager workflow. This is part of phase-4 implementation for RewardSTACK integration, representing the final production deployment milestone.",
        "testStrategy": "Deployment checklist validation, monitoring for errors, and rollback simulation.",
        "subtasks": [
          {
            "id": 1,
            "title": "Prepare and Validate Production Environment for RewardSTACK Deployment",
            "description": "Ensure the production environment is ready for deployment, including running the full test suite, applying database migrations, and configuring all necessary infrastructure and environment variables.",
            "dependencies": [],
            "details": "Run automated and manual tests to validate application stability. Apply all required database migrations using migration tools. Confirm that environment variables, API keys, and configuration files are correctly set for production. Ensure infrastructure components (servers, networking, databases) are provisioned and healthy. Document any environment-specific settings.",
            "status": "pending",
            "testStrategy": "Verify all tests pass in CI/CD pipeline. Confirm successful migration on staging and production. Check environment configuration via smoke tests."
          },
          {
            "id": 2,
            "title": "Deploy Backend, Configure Webhooks, and Enable Feature Flags",
            "description": "Deploy the backend application to production, configure RewardSTACK webhook endpoints, and enable the feature flag for the manager workflow.",
            "dependencies": [
              1
            ],
            "details": "Use automated deployment scripts or CI/CD pipelines to deploy the backend. Register and verify webhook endpoints with RewardSTACK. Enable the feature flag for the manager workflow in the production environment. Monitor deployment logs for errors. Verify that the deployment is successful and the new features are accessible only as intended.",
            "status": "pending",
            "testStrategy": "Monitor deployment logs for errors. Perform end-to-end tests on webhook functionality and feature flag gating. Confirm successful email delivery and manager workflow access."
          },
          {
            "id": 3,
            "title": "Monitor Production, Verify Integration, and Document Rollback Plan",
            "description": "Monitor application logs, verify RewardSTACK integration (including email delivery), and document a clear rollback plan in case of deployment issues.",
            "dependencies": [
              2
            ],
            "details": "Set up real-time monitoring and alerting for application errors, webhook failures, and email delivery issues. Perform manual verification of key integration points. Document step-by-step rollback procedures, including how to revert database migrations, disable feature flags, and restore previous application versions. Simulate a rollback in a staging environment to validate the plan.",
            "status": "pending",
            "testStrategy": "Review monitoring dashboards for anomalies. Test rollback steps in staging and confirm system restoration. Validate that rollback documentation is clear and actionable."
          }
        ]
      },
      {
        "id": 61,
        "title": "Post-Deployment Monitoring and Success Metrics Tracking",
        "description": "Monitor production metrics, email delivery, dashboard performance, and adoption rate for RewardSTACK integration in phase-4.",
        "status": "pending",
        "dependencies": [
          60
        ],
        "priority": "medium",
        "details": "Track test coverage, dashboard response times, email failure rates, security audits, and manager adoption. Use analytics and alerting tools for real-time monitoring. Focus on RewardSTACK-specific metrics including reward issuance rates, participant sync performance, catalog access patterns, and integration health. This is a phase-4 monitoring task ensuring the RewardSTACK system operates reliably in production.",
        "testStrategy": "Review metrics dashboards, audit logs, and user feedback for first week. Include RewardSTACK-specific monitoring validation and integration health checks.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Automated Real-Time Monitoring for Production Metrics",
            "description": "Implement automated systems to continuously track production metrics, including dashboard response times, email delivery rates, and error rates.",
            "dependencies": [],
            "details": "Configure analytics and alerting tools to monitor key metrics in real time. Instrument logging for dashboard performance, email failures, and system anomalies. Ensure alert thresholds are defined to trigger incident responses when metrics deviate from expected values.",
            "status": "pending",
            "testStrategy": "Verify real-time dashboards and alerting mechanisms by simulating metric deviations and confirming alerts are triggered and logged."
          },
          {
            "id": 2,
            "title": "Conduct Regular Security Audits and Data Integrity Checks",
            "description": "Perform scheduled security audits and data integrity checks to identify vulnerabilities and ensure compliance with relevant standards.",
            "dependencies": [
              1
            ],
            "details": "Use automated security scanning tools and manual inspections to assess system security. Run periodic data integrity checks to detect missing values, inconsistencies, or drift between expected and actual data. Document all findings and remediation actions for audit trails.",
            "status": "pending",
            "testStrategy": "Review audit logs and security scan reports; validate that detected issues are addressed and documented. Confirm data integrity by running test cases with known anomalies."
          },
          {
            "id": 3,
            "title": "Track and Analyze Adoption Rate and Success Metrics",
            "description": "Monitor manager adoption rates and success metrics to evaluate post-deployment impact and user engagement.",
            "dependencies": [
              1
            ],
            "details": "Collect usage analytics from dashboards and email systems to measure adoption and engagement. Define KPIs such as active users, feature utilization, and feedback scores. Regularly review these metrics and gather user feedback to identify areas for improvement.",
            "status": "pending",
            "testStrategy": "Analyze adoption metrics and compare against predefined KPIs; conduct user surveys and review feedback for qualitative assessment."
          },
          {
            "id": 4,
            "title": "Monitor RewardSTACK Integration Health and Performance",
            "description": "Implement specialized monitoring for RewardSTACK-specific metrics including reward issuance rates, participant sync performance, and catalog access patterns.",
            "dependencies": [
              1
            ],
            "details": "Set up monitoring for RewardSTACK API response times, reward processing success/failure rates, participant sync batch performance, and catalog caching effectiveness. Track integration-specific errors, timeout rates, and data consistency between local database and RewardSTACK systems. Configure alerts for RewardSTACK service degradation or integration failures.",
            "status": "pending",
            "testStrategy": "Validate RewardSTACK monitoring dashboards show accurate integration metrics; test alert triggers for API failures and performance degradation scenarios."
          }
        ]
      },
      {
        "id": 62,
        "title": "Set Up Project Dependencies and Tooling",
        "description": "Install and configure all required dependencies, libraries, and tools for the AI Email Template Editor project. This is a foundational phase-1 task for setting up the development environment with AI-powered email template editing capabilities.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "- Use pnpm as the package manager for consistency and speed.\n- Install Vercel AI SDK v3.4+, @ai-sdk/anthropic, @monaco-editor/react, react-resizable-panels, juice, html-react-parser, isomorphic-dompurify, and other listed dependencies.\n- Set up .env.local with AI_GATEWAY_URL and ANTHROPIC_API_KEY.\n- Ensure Node.js >=18 and TypeScript >=5.2 are used for best compatibility.\n- Add linting (eslint) and formatting (prettier) configs for code quality.\n- Research confirms these are the latest stable versions as of October 2025.\n- Tags: ai-email, dependencies, setup, phase-1",
        "testStrategy": "Run 'pnpm install' and verify all dependencies resolve. Test a basic import from each library in a dummy file. Confirm environment variables are loaded and accessible.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project and Install Core Dependencies",
            "description": "Set up the project directory, initialize with pnpm, and install all required dependencies and libraries for the AI Email Template Editor.",
            "dependencies": [],
            "details": "Create the project directory if it does not exist. Run 'pnpm init' to generate package.json. Use 'pnpm install' to add Vercel AI SDK v3.4+, @ai-sdk/anthropic, @monaco-editor/react, react-resizable-panels, juice, html-react-parser, isomorphic-dompurify, and any other listed dependencies. Ensure Node.js >=18 and TypeScript >=5.2 are installed and configured for compatibility.",
            "status": "pending",
            "testStrategy": "Run 'pnpm install' and verify all dependencies are present in node_modules. Check that 'node -v' and 'tsc -v' meet version requirements."
          },
          {
            "id": 2,
            "title": "Configure Environment Variables and API Keys",
            "description": "Set up the .env.local file with required environment variables for AI Gateway and Anthropic API access.",
            "dependencies": [
              1
            ],
            "details": "Create or update the .env.local file in the project root. Add AI_GATEWAY_URL and ANTHROPIC_API_KEY with appropriate values. Ensure these variables are loaded by the application and accessible in both development and production environments.",
            "status": "pending",
            "testStrategy": "Start the development server and log process.env variables to confirm they are loaded. Attempt a test API call using the configured keys."
          },
          {
            "id": 3,
            "title": "Set Up Linting and Formatting Tools",
            "description": "Add and configure ESLint and Prettier for code quality and formatting consistency across the project.",
            "dependencies": [
              1
            ],
            "details": "Install eslint and prettier as dev dependencies using pnpm. Generate configuration files (.eslintrc, .prettierrc) with recommended settings for TypeScript and React. Optionally, add scripts to package.json for linting and formatting. Verify integration with IDE/editor.",
            "status": "pending",
            "testStrategy": "Run 'pnpm lint' and 'pnpm format' (or equivalent scripts). Confirm that linting errors and formatting issues are detected and can be auto-fixed."
          }
        ]
      },
      {
        "id": 63,
        "title": "Design and Migrate Email Template Database Schema",
        "description": "Define and migrate the EmailTemplate model in Prisma schema, including workspace relations and variable support. Tags: ai-email, database, prisma, phase-1",
        "status": "pending",
        "dependencies": [
          62
        ],
        "priority": "high",
        "details": "- Add EmailTemplate model to prisma/schema.prisma as specified in PRD.\n- Include fields: id, workspaceId, name, subject, html, variables (String[]), isBuiltIn, lastUsedAt, usageCount, createdAt, updatedAt.\n- Add appropriate indexes for workspaceId and isBuiltIn.\n- Use Prisma Migrate to generate and apply migration.\n- Research: Prisma 5.x is current; use @db.Uuid for UUID fields for PostgreSQL compatibility.\n- Tags: ai-email, database, prisma, phase-1",
        "testStrategy": "Run 'pnpm prisma migrate dev' and verify migration applies without errors. Check schema in database using Prisma Studio. Validate indexes exist.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define EmailTemplate Model in Prisma Schema",
            "description": "Design the EmailTemplate model in prisma/schema.prisma, including all required fields, workspace relation, and variable support.",
            "dependencies": [],
            "details": "Add the EmailTemplate model to the Prisma schema using PSL. Include fields: id (UUID, @db.Uuid), workspaceId (UUID, @db.Uuid), name, subject, html, variables (String[]), isBuiltIn, lastUsedAt, usageCount, createdAt, updatedAt. Define the relation to the Workspace model and ensure all field types and defaults match the PRD. Add indexes for workspaceId and isBuiltIn as needed.",
            "status": "pending",
            "testStrategy": "Review schema.prisma for correct model definition, field types, and relation syntax. Validate with 'prisma validate'."
          },
          {
            "id": 2,
            "title": "Generate and Apply Prisma Migration",
            "description": "Use Prisma Migrate to generate and apply the migration for the new EmailTemplate model and its indexes.",
            "dependencies": [
              1
            ],
            "details": "Run 'pnpm prisma migrate dev' to generate and apply the migration based on the updated schema. Ensure the migration creates the EmailTemplate table with all specified fields, relations, and indexes in the PostgreSQL database.",
            "status": "pending",
            "testStrategy": "Verify migration applies without errors. Use Prisma Studio or direct SQL queries to confirm the table structure, field types, and indexes."
          },
          {
            "id": 3,
            "title": "Validate Schema and Indexes in Database",
            "description": "Confirm that the EmailTemplate table, relations, and indexes exist and match requirements in the live database.",
            "dependencies": [
              2
            ],
            "details": "Inspect the database using Prisma Studio or a SQL client. Check that all fields, types, relations, and indexes (workspaceId, isBuiltIn) are present and correctly configured. Ensure compatibility with Prisma 5.x and PostgreSQL UUID fields.",
            "status": "pending",
            "testStrategy": "Cross-check the live schema against the PRD and schema.prisma. Validate with test queries and Prisma Studio inspection."
          }
        ]
      },
      {
        "id": 64,
        "title": "Configure AI SDK and Anthropic Model Integration",
        "description": "Set up Vercel AI SDK and Anthropic Claude 3.5 Sonnet model with streaming and rate limiting. Tags: ai-email, ai, config, phase-1",
        "status": "pending",
        "dependencies": [
          62
        ],
        "priority": "high",
        "details": "- Create lib/ai/config.ts to export aiConfig and rateLimits as per PRD.\n- Use Vercel AI SDK v3.4+ and @ai-sdk/anthropic for Claude 3.5 Sonnet.\n- Implement workspace-based rate limiting (10 req/min, 50k tokens/min).\n- Add cost tracking and 1-hour cache TTL using in-memory or Redis cache.\n- Research: Vercel AI SDK v3.4+ supports streaming and Anthropic Claude 3.5 Sonnet as of October 2025.\n- This is part of phase-1 implementation for AI email functionality.",
        "testStrategy": "Write a test script to call the AI SDK with a sample prompt and verify streaming response. Simulate rate limit and confirm error is thrown. Check logs for cost tracking.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Vercel AI SDK and Anthropic Claude 3.5 Sonnet Model",
            "description": "Install and configure Vercel AI SDK v3.4+ and @ai-sdk/anthropic for Claude 3.5 Sonnet model integration.",
            "dependencies": [],
            "details": "Install the required npm packages (vercel-ai-sdk v3.4+ and @ai-sdk/anthropic). Create lib/ai/config.ts to export aiConfig with model parameters (e.g., model name, API key, streaming options). Ensure the Claude 3.5 Sonnet model is correctly referenced and streaming is enabled in the configuration.",
            "status": "pending",
            "testStrategy": "Write a test script to send a sample prompt and verify streaming response from Claude 3.5 Sonnet."
          },
          {
            "id": 2,
            "title": "Implement Workspace-Based Rate Limiting and Cost Tracking",
            "description": "Add logic for workspace-based rate limiting (10 requests/min, 50k tokens/min) and track API usage costs.",
            "dependencies": [
              1
            ],
            "details": "Integrate rate limiting middleware in the API layer using in-memory or Redis cache. Track requests and tokens per workspace, enforcing limits as specified. Implement cost tracking based on Anthropic's pricing ($3/million input tokens, $15/million output tokens) and log usage for each workspace.",
            "status": "pending",
            "testStrategy": "Simulate exceeding rate limits and verify error responses. Check logs for accurate cost tracking per workspace."
          },
          {
            "id": 3,
            "title": "Configure 1-Hour Cache TTL for AI Responses",
            "description": "Set up caching for AI responses with a 1-hour TTL using in-memory or Redis cache.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement caching logic in lib/ai/config.ts or relevant middleware. Store AI responses with a 1-hour expiration to reduce redundant requests and improve performance. Ensure cache invalidation and retrieval are handled correctly.",
            "status": "pending",
            "testStrategy": "Send repeated requests and verify cached responses are returned within TTL. Confirm cache expires after 1 hour and new responses are generated."
          }
        ]
      },
      {
        "id": 65,
        "title": "Implement Split View Editor Layout",
        "description": "Develop the SplitViewEditor React component with resizable panels for HTML editing and live preview. This is a core UI component for the AI email editor with layout management capabilities, tagged as ai-email, ui, layout, phase-1.",
        "status": "pending",
        "dependencies": [
          62
        ],
        "priority": "high",
        "details": "- Use react-resizable-panels for horizontal split layout.\n- Left panel: HTMLEditor (Monaco), right panel: EmailPreview.\n- Add panel size persistence using localStorage.\n- Ensure responsive design for desktop and mobile.\n- Research: react-resizable-panels v2.x is stable and supports controlled layouts.\n- Tags: ai-email, ui, layout, phase-1",
        "testStrategy": "Render SplitViewEditor in Storybook and verify resizing, persistence, and responsiveness. Test on Chrome and Safari. Validate component integration with AI email editor workflow.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up SplitViewEditor with react-resizable-panels for Horizontal Layout",
            "description": "Create the SplitViewEditor React component using react-resizable-panels to establish a horizontal split layout with two panels.",
            "dependencies": [],
            "details": "Install react-resizable-panels and import PanelGroup, Panel, and PanelResizeHandle. Implement a PanelGroup with direction='horizontal', placing the HTMLEditor (Monaco) in the left panel and EmailPreview in the right panel. Ensure the basic split and resizing functionality works.",
            "status": "pending",
            "testStrategy": "Render SplitViewEditor in Storybook and verify that the two panels are displayed side by side and can be resized horizontally."
          },
          {
            "id": 2,
            "title": "Implement Panel Size Persistence with localStorage",
            "description": "Enable persistence of panel sizes by saving and restoring layout state using localStorage.",
            "dependencies": [
              1
            ],
            "details": "Use the autoSaveId prop or manually handle onLayout events to store panel sizes in localStorage. On component mount, read the saved sizes and initialize the panel layout accordingly. Ensure the layout restores correctly after page reload.",
            "status": "pending",
            "testStrategy": "Resize panels, reload the page, and verify that the previous sizes are restored. Test in multiple browsers."
          },
          {
            "id": 3,
            "title": "Ensure Responsive Design for Desktop and Mobile",
            "description": "Adapt the SplitViewEditor layout and resizing behavior for optimal usability on both desktop and mobile devices.",
            "dependencies": [
              1,
              2
            ],
            "details": "Apply responsive CSS and adjust panel minimum/maximum sizes for different screen widths. Test touch and mouse interactions for resizing. Ensure both panels remain usable and readable on small screens.",
            "status": "pending",
            "testStrategy": "Test resizing and layout on various screen sizes and devices (desktop, tablet, mobile). Verify usability and appearance in Chrome and Safari."
          }
        ]
      },
      {
        "id": 66,
        "title": "Build HTML Editor Component with Monaco Editor",
        "description": "Integrate Monaco Editor for HTML editing with syntax highlighting, auto-completion, and template variable support. Tags: ai-email, ui, editor, monaco, phase-2",
        "status": "pending",
        "dependencies": [
          65
        ],
        "priority": "high",
        "details": "- Use @monaco-editor/react for embedding Monaco in React.\n- Enable HTML language mode, word wrap, and dark theme.\n- Implement auto-completion for HTML tags and template variables (e.g., {{variable_name}}).\n- Track text selection for contextual AI edits.\n- Optimize for large templates (virtualization, debounce onChange).\n- Research: Monaco Editor v0.47+ supports custom completion providers.\n- Tags: ai-email, ui, editor, monaco, phase-2",
        "testStrategy": "Test editor with large (50KB) HTML files. Verify syntax highlighting, auto-complete for variables, and selection tracking. Run performance profiling.",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Monaco Editor into React Component",
            "description": "Set up the Monaco Editor using @monaco-editor/react within a new or existing React component, ensuring HTML language mode, word wrap, and dark theme are enabled.",
            "dependencies": [],
            "details": "Install @monaco-editor/react and monaco-editor packages. Create a React component that renders the Editor with props: language='html', theme='vs-dark', and options for word wrap. Ensure the editor mounts and updates correctly within the React lifecycle.",
            "status": "pending",
            "testStrategy": "Render the component in Storybook or a test page. Verify the editor loads with HTML syntax highlighting, dark theme, and word wrap enabled."
          },
          {
            "id": 2,
            "title": "Implement Auto-Completion for HTML Tags and Template Variables",
            "description": "Add custom completion providers to Monaco Editor for HTML tags and template variables (e.g., {{variable_name}}) using Monaco's API.",
            "dependencies": [
              1
            ],
            "details": "Use the Monaco API to register a completion provider for HTML. Provide suggestions for standard HTML tags and dynamically for template variables. Ensure compatibility with Monaco Editor v0.47+ and test with various variable patterns.",
            "status": "pending",
            "testStrategy": "Type partial HTML tags and template variables in the editor. Confirm that relevant suggestions appear and can be inserted."
          },
          {
            "id": 3,
            "title": "Optimize Editor for Large Templates and Track Text Selection",
            "description": "Enhance performance for large HTML templates and implement logic to track text selection for contextual AI edits.",
            "dependencies": [
              1
            ],
            "details": "Implement virtualization or debounce onChange handlers to reduce performance overhead with large files. Use Monaco's selection API to monitor and expose current selection state for integration with AI features.",
            "status": "pending",
            "testStrategy": "Load a large (50KB+) HTML file and monitor editor responsiveness. Select text and verify selection state is tracked and available for downstream logic."
          }
        ]
      },
      {
        "id": 67,
        "title": "Develop Email Preview Component with Live Desktop/Mobile Toggle",
        "description": "Create EmailPreview component to render processed HTML with variable substitution, CSS inlining, and responsive view toggling. Tagged as ai-email, ui, preview, phase-2 for project organization.",
        "status": "pending",
        "dependencies": [
          65
        ],
        "priority": "high",
        "details": "- Use Juice for CSS inlining to ensure email compatibility.\n- Replace template variables with sample data for preview.\n- Render HTML in a sandboxed iframe to prevent XSS.\n- Add desktop/mobile toggle (375px width for mobile).\n- Research: Juice v9.x is current and supports async inlining; use DOMPurify for extra sanitization if needed.\n- Tags: ai-email, ui, preview, phase-2",
        "testStrategy": "Test preview rendering with various HTML templates, including those with external CSS. Verify variable substitution and iframe sandboxing. Check for XSS vectors.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement HTML Processing with Variable Substitution and CSS Inlining",
            "description": "Process the input email template HTML by substituting template variables with sample data and inlining CSS using Juice.",
            "dependencies": [],
            "details": "Set up logic to parse the template HTML, replace all variable placeholders with sample data, and use Juice v9.x for asynchronous CSS inlining to ensure compatibility across email clients. Ensure the processed HTML is ready for preview rendering.",
            "status": "pending",
            "testStrategy": "Unit test with multiple template samples containing variables and external CSS. Verify correct substitution and CSS inlining."
          },
          {
            "id": 2,
            "title": "Render Processed HTML in a Sandboxed Iframe with Sanitization",
            "description": "Safely render the processed HTML inside a sandboxed iframe to prevent XSS, using DOMPurify for additional sanitization if needed.",
            "dependencies": [
              1
            ],
            "details": "Create an iframe component with sandbox attributes to isolate the previewed HTML. Integrate DOMPurify to sanitize the HTML before rendering, ensuring no malicious scripts can execute. Confirm that the preview matches the intended email output.",
            "status": "pending",
            "testStrategy": "Test with HTML containing scripts and unsafe content. Validate that XSS vectors are blocked and the preview displays correctly."
          },
          {
            "id": 3,
            "title": "Add Responsive Desktop/Mobile Toggle for Email Preview",
            "description": "Implement a toggle UI to switch the preview between desktop and mobile views, with mobile set to 375px width.",
            "dependencies": [
              2
            ],
            "details": "Build a toggle control that adjusts the iframe/container width to simulate desktop and mobile email clients. Ensure the preview updates live when toggled and accurately reflects responsive design. Mobile view should use a fixed width of 375px.",
            "status": "pending",
            "testStrategy": "Interactively test the toggle with various templates. Confirm correct rendering at both widths and smooth transitions."
          }
        ]
      },
      {
        "id": 68,
        "title": "Implement Template CRUD API Endpoints",
        "description": "Create Next.js API routes for listing, creating, updating, and deleting email templates with workspace isolation and validation. Tagged as ai-email, api, crud, phase-2.",
        "status": "pending",
        "dependencies": [
          63
        ],
        "priority": "high",
        "details": "- Implement GET/POST at /api/workspaces/[slug]/email-templates for list/create.\n- Implement PUT/DELETE at /api/workspaces/[slug]/email-templates/[id] for update/delete.\n- Use Zod for request validation and variable extraction.\n- Add audit logging for updates/deletes.\n- Research: Next.js 14+ API routes support edge runtime for low latency; Zod v3.x is current.\n- Tags: ai-email, api, crud, phase-2",
        "testStrategy": "Write unit tests for all API endpoints using Jest or Vitest. Test workspace isolation and validation logic. Simulate concurrent requests.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Next.js API Routes for Email Template CRUD Operations",
            "description": "Create API route handlers for listing, creating, updating, and deleting email templates, ensuring workspace isolation.",
            "dependencies": [],
            "details": "Set up GET and POST handlers at /api/workspaces/[slug]/email-templates for listing and creating templates. Implement PUT and DELETE handlers at /api/workspaces/[slug]/email-templates/[id] for updating and deleting templates. Ensure all operations are scoped to the workspace identified by [slug]. Use Next.js 14+ route handlers and support edge runtime for low latency.",
            "status": "pending",
            "testStrategy": "Write unit and integration tests for each endpoint using Jest or Vitest. Test CRUD operations for correct workspace isolation and error handling."
          },
          {
            "id": 2,
            "title": "Integrate Zod Validation and Template Variable Extraction",
            "description": "Apply Zod schemas for request validation and extract template variables from HTML content.",
            "dependencies": [
              1
            ],
            "details": "Define Zod schemas for validating incoming request bodies for create and update operations. Use Zod to parse and validate all input data, including workspace slug and template fields. Implement logic to extract variables from template HTML using regex and update the EmailTemplate.variables field accordingly.",
            "status": "pending",
            "testStrategy": "Test validation logic with valid and invalid payloads. Verify variable extraction with various HTML samples, including edge cases."
          },
          {
            "id": 3,
            "title": "Add Audit Logging for Update and Delete Operations",
            "description": "Implement audit logging for all update and delete actions on email templates.",
            "dependencies": [
              1,
              2
            ],
            "details": "For PUT and DELETE requests, log the action, user, timestamp, and affected template details to an audit log. Ensure logs are written reliably and can be queried for compliance. Integrate logging into the API route handlers without impacting performance.",
            "status": "pending",
            "testStrategy": "Simulate update and delete requests and verify that audit logs are created with correct details. Test log retrieval and error scenarios."
          }
        ]
      },
      {
        "id": 69,
        "title": "Create Template Picker and Management UI",
        "description": "Develop TemplatePicker React component for selecting, creating, and managing templates with metadata display. Tags: ai-email, ui, management, phase-2",
        "status": "pending",
        "dependencies": [
          68
        ],
        "priority": "medium",
        "details": "- Use SWR for data fetching from template API.\n- Implement dropdown selection, show last used/usage count, and add 'New Template' button.\n- Optimize for performance with 100+ templates (virtualized list if needed).\n- Research: SWR v2.x is recommended for React 18+.\n- This is part of phase-2 implementation for AI email template management.",
        "testStrategy": "Test with large template lists. Verify selection, creation, and metadata display. Check accessibility (keyboard navigation).",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement TemplatePicker Component with SWR Data Fetching",
            "description": "Build the core TemplatePicker React component that fetches template data using SWR and displays a dropdown for template selection.",
            "dependencies": [],
            "details": "Set up SWR v2.x for efficient data fetching from the template API. Render a dropdown or virtualized list for template selection, ensuring performance with 100+ templates. Integrate metadata display (e.g., last used, usage count) within the dropdown items. Ensure the component is optimized for React 18+.",
            "status": "pending",
            "testStrategy": "Test with a mock API returning 100+ templates. Verify dropdown renders efficiently, metadata is displayed, and selection works. Use React Testing Library for interaction and performance checks."
          },
          {
            "id": 2,
            "title": "Add Template Creation and Management Features",
            "description": "Extend the TemplatePicker to support creating new templates and managing existing ones, including UI controls and API integration.",
            "dependencies": [
              1
            ],
            "details": "Implement a 'New Template' button that opens a modal or form for template creation. Integrate API calls for creating and updating templates. Provide UI for editing or deleting templates as needed. Ensure state updates and SWR cache invalidation after changes.",
            "status": "pending",
            "testStrategy": "Simulate template creation, editing, and deletion. Verify UI updates and SWR cache refresh. Test error handling and form validation."
          },
          {
            "id": 3,
            "title": "Enhance Accessibility and Usability for Large Template Sets",
            "description": "Optimize the TemplatePicker for accessibility and usability, especially with large numbers of templates.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement keyboard navigation and ARIA roles for dropdown and management controls. Use a virtualized list (e.g., react-window) for performance with 100+ templates. Ensure all interactive elements are accessible and provide clear focus states.",
            "status": "pending",
            "testStrategy": "Test keyboard navigation, screen reader compatibility, and performance with large datasets. Use accessibility testing tools (e.g., axe-core) to validate compliance."
          }
        ]
      },
      {
        "id": 70,
        "title": "Assemble Main Email Settings Page",
        "description": "Build the main settings page integrating TemplatePicker, SplitViewEditor, and save/cancel controls. This is part of phase-2 implementation for AI email template management with comprehensive UI integration.",
        "status": "pending",
        "dependencies": [
          65,
          69
        ],
        "priority": "medium",
        "details": "- Use Next.js server components for initial data fetch.\n- Integrate all child components and manage state transitions.\n- Add loading, error, and empty states.\n- Research: Next.js 14+ supports server components and client/server interop.\n- Tags: ai-email, ui, settings, phase-2",
        "testStrategy": "Test full page flow: load, select, edit, save, and cancel. Verify state consistency and error handling. Validate AI email template management workflow integration.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Server-Side Data Fetching and Page Layout",
            "description": "Set up the main email settings page as a Next.js server component to fetch initial template and settings data. Integrate the page layout with placeholders for TemplatePicker, SplitViewEditor, and save/cancel controls.",
            "dependencies": [],
            "details": "Use Next.js 14+ server components to fetch and render initial data (templates, current settings). Structure the page to include regions for TemplatePicker, SplitViewEditor, and action controls. Implement basic loading, error, and empty states using Suspense and error boundaries. Ensure environment variables are properly configured for API endpoints. This supports the phase-2 AI email template management workflow.",
            "status": "pending",
            "testStrategy": "Verify that the page loads initial data correctly, displays appropriate states (loading, error, empty), and renders all major UI regions. Test with mocked API responses."
          },
          {
            "id": 2,
            "title": "Integrate and Wire Up Child Components",
            "description": "Embed and connect TemplatePicker and SplitViewEditor within the main page. Manage state transitions between template selection, editing, and preview.",
            "dependencies": [],
            "details": "Embed TemplatePicker and SplitViewEditor as client components within the server-rendered page. Use React context or prop drilling to share selected template and editor state. Implement handlers for template selection changes, editor content updates, and preview refreshes. Ensure panel size persistence (localStorage) works in SplitViewEditor. Add client-side state for unsaved changes and manage transitions between view/edit modes. Support AI email template management features including metadata display and template creation workflows.",
            "status": "pending",
            "testStrategy": "Test template selection, editor updates, and preview synchronization. Verify panel resizing and persistence. Check that unsaved changes are tracked and UI responds to state transitions. Validate AI email template management integration."
          },
          {
            "id": 3,
            "title": "Add Save/Cancel Controls and Finalize State Management",
            "description": "Implement save and cancel action buttons, handle submission to the backend, and manage loading/error feedback during operations.",
            "dependencies": [],
            "details": "Add save and cancel buttons to the page layout. Connect these to API calls that persist changes (e.g., updating the selected template or editor content). Handle loading and error states during submission. Reset or revert state on cancel. Ensure all component states (selected template, editor content, preview, unsaved changes) are consistent before and after save/cancel operations. Consider adding confirmation dialogs for unsaved changes. Support phase-2 AI email template management persistence and validation.",
            "status": "pending",
            "testStrategy": "Test save and cancel flows: verify successful submission, error handling, and state reversion. Check for race conditions and ensure UI feedback is clear during operations. Validate that unsaved changes are handled gracefully. Test AI email template management save operations."
          }
        ]
      },
      {
        "id": 71,
        "title": "Develop AI Assist Hook and Prompt Engineering",
        "description": "Implement useAIEmailAssist React hook and prompt builder for AI-powered HTML editing with streaming and variable preservation. Tagged as ai-email, ai, hooks, prompts, phase-3 for project organization.",
        "status": "pending",
        "dependencies": [
          64
        ],
        "priority": "high",
        "details": "- Create useAIEmailAssist hook using Vercel AI SDK's useCompletion.\n- Build prompt builder enforcing email-safe HTML, variable preservation, and code block wrapping.\n- Handle streaming responses and extract HTML from AI output.\n- Research: Prompt engineering best practices for Claude 3.5 Sonnet as of Oct 2025 recommend explicit constraints and code block delimiters.\n- Tags: ai-email, ai, hooks, prompts, phase-3",
        "testStrategy": "Write unit tests for prompt generation and AI response parsing. Simulate streaming and error scenarios.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement useAIEmailAssist Custom React Hook with Streaming Support",
            "description": "Develop a reusable useAIEmailAssist hook using Vercel AI SDK's useCompletion to handle AI-powered HTML editing with streaming and variable preservation.",
            "dependencies": [],
            "details": "Create a custom React hook that wraps useCompletion from the Vercel AI SDK. Ensure the hook manages streaming AI responses, preserves template variables, and exposes state and handlers for integration with components. Follow React best practices for custom hooks, including state management and side effect cleanup.",
            "status": "pending",
            "testStrategy": "Write unit tests to simulate streaming AI responses, verify variable preservation, and test error handling within the hook."
          },
          {
            "id": 2,
            "title": "Design and Implement Prompt Builder for Email-Safe HTML and Variable Preservation",
            "description": "Build a prompt builder utility that generates prompts enforcing email-safe HTML, variable preservation, and code block wrapping for Claude 3.5 Sonnet.",
            "dependencies": [
              1
            ],
            "details": "Develop a function or module that constructs prompts with explicit constraints: require AI output to be wrapped in code blocks, preserve all template variables, and generate only email-safe HTML. Incorporate prompt engineering best practices for Claude 3.5 Sonnet as of Oct 2025, such as explicit instructions and delimiter usage.",
            "status": "pending",
            "testStrategy": "Write unit tests for prompt generation, ensuring all constraints are present. Validate that generated prompts produce correctly formatted AI responses in integration tests."
          },
          {
            "id": 3,
            "title": "Parse and Extract HTML from Streaming AI Output with Variable Integrity",
            "description": "Implement logic to handle streaming AI responses, extract HTML content, and ensure all template variables are preserved in the output.",
            "dependencies": [
              1,
              2
            ],
            "details": "Develop a parser that processes streamed AI output, extracts HTML from code blocks, and verifies that all template variables remain intact. Handle edge cases such as incomplete streams or malformed outputs. Integrate this logic into the hook or as a supporting utility.",
            "status": "pending",
            "testStrategy": "Test with simulated streaming outputs, including malformed and partial responses. Verify correct HTML extraction and variable preservation through automated tests."
          }
        ]
      },
      {
        "id": 72,
        "title": "Implement AI Assist Panel and Suggestion Controls",
        "description": "Create AIAssistPanel UI for user instructions, quick prompts, and suggestion approval/rejection in the editor. Tagged as ai-email, ai, ui, panel, phase-3.",
        "status": "pending",
        "dependencies": [
          66,
          71
        ],
        "priority": "medium",
        "details": "- Build instruction input with quick prompt buttons.\n- Show processing state and contextual hints.\n- Add accept/reject controls to HTMLEditor with keyboard shortcuts (Cmd+Enter).\n- Display diff indicators for suggestions.\n- Research: Use React context or props for suggestion state propagation.\n- Tags: ai-email, ai, ui, panel, phase-3",
        "testStrategy": "Test UI interactions for instruction entry, quick prompts, and suggestion approval/rejection. Verify keyboard shortcuts and diff display.",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop AI Assist Panel UI with Instruction Input and Quick Prompts",
            "description": "Create the AIAssistPanel component to allow users to enter instructions and select from quick prompt buttons.",
            "dependencies": [],
            "details": "Implement a React component for the AI Assist Panel using a library such as Syncfusion's AIAssistViewComponent. Include an instruction input field and a set of quick prompt buttons. Configure prompt suggestions and responses, and ensure the UI displays contextual hints and a processing state when interacting with the AI service.",
            "status": "pending",
            "testStrategy": "Render the panel in Storybook and verify instruction entry, prompt selection, and display of contextual hints and processing state."
          },
          {
            "id": 2,
            "title": "Integrate Suggestion Approval/Rejection Controls in HTMLEditor",
            "description": "Add accept and reject controls for AI-generated suggestions within the HTMLEditor, including keyboard shortcuts.",
            "dependencies": [
              1
            ],
            "details": "Extend the HTMLEditor to display AI suggestions with diff indicators. Implement accept/reject buttons and support keyboard shortcuts (Cmd+Enter for accept). Ensure that suggestion state is propagated using React context or props, and that UI updates correctly when suggestions are approved or rejected.",
            "status": "pending",
            "testStrategy": "Test suggestion approval/rejection via both UI controls and keyboard shortcuts. Verify correct state propagation and diff indicator display."
          },
          {
            "id": 3,
            "title": "Implement Suggestion State Propagation and Diff Indicators",
            "description": "Ensure suggestion state is managed and propagated across components, and display diff indicators for changes.",
            "dependencies": [
              2
            ],
            "details": "Research and implement state management for suggestion approval/rejection using React context or props. Display visual diff indicators in the editor to highlight changes suggested by the AI. Confirm that state updates are reflected in both the AI Assist Panel and HTMLEditor.",
            "status": "pending",
            "testStrategy": "Unit test state propagation logic and verify that diff indicators accurately reflect suggestion changes in the UI."
          }
        ]
      },
      {
        "id": 73,
        "title": "Integrate AI Assist Workflow with Editor and Preview",
        "description": "Wire up useAIEmailAssist, AIAssistPanel, HTMLEditor, and EmailPreview for a seamless AI-powered editing experience. This is a phase-3 AI workflow integration task.",
        "status": "pending",
        "dependencies": [
          67,
          72
        ],
        "priority": "high",
        "details": "- Pass suggestion state and actions between components.\n- Update preview on suggestion changes and handle optimistic UI updates.\n- Manage state for accept/reject and error feedback.\n- Research: Use React 18+ context and hooks for state management.\n- Tags: ai-email, ai, workflow, phase-3",
        "testStrategy": "Perform end-to-end tests: enter instruction, receive AI suggestion, preview, accept/reject, and verify editor/preview update.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Context API for State Management",
            "description": "Implement React Context API to manage and share state between components like useAIEmailAssist, AIAssistPanel, HTMLEditor, and EmailPreview.",
            "dependencies": [],
            "details": "Create a context provider using createContext and manage state for suggestions, accept/reject actions, and error feedback. Use React 18+ hooks for efficient state updates.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Integrate Components with Context API",
            "description": "Wire up components to use the context API for seamless data sharing and updates.",
            "dependencies": [
              1
            ],
            "details": "Pass suggestion state and actions between components using the context API. Ensure that the EmailPreview updates dynamically based on suggestion changes.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Implement Optimistic UI Updates and Error Handling",
            "description": "Develop optimistic UI updates for suggestion changes and handle accept/reject actions with error feedback.",
            "dependencies": [
              2
            ],
            "details": "Implement logic to handle optimistic UI updates when suggestions are applied or rejected. Manage error feedback for failed operations and ensure that the editor and preview reflect these changes accurately.",
            "status": "pending",
            "testStrategy": "Perform end-to-end tests to verify UI updates and error handling"
          }
        ]
      },
      {
        "id": 74,
        "title": "Implement Template Variable Extraction and Management",
        "description": "Auto-detect template variables in HTML, update EmailTemplate.variables, and warn on variable removal. Tagged as ai-email, templates, variables, phase-3.",
        "status": "pending",
        "dependencies": [
          73
        ],
        "priority": "medium",
        "details": "- Use regex /{{([a-zA-Z_][a-zA-Z0-9_]*)}}/g to extract variables.\n- Update variables on save and display in UI.\n- Warn if AI removes variables during edit.\n- Research: Regex approach is standard; consider edge cases for nested or malformed variables.\n- Tags: ai-email, templates, variables, phase-3",
        "testStrategy": "Test variable extraction with various HTML samples. Verify UI updates and warning logic.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Regex-Based Extraction of Template Variables from HTML",
            "description": "Develop logic to automatically detect and extract template variables from HTML using the specified regex pattern.",
            "dependencies": [],
            "details": "Use the regex /{{([a-zA-Z_][a-zA-Z0-9_]*)}}/g to scan HTML content and extract all variable names. Ensure the extraction handles multiple occurrences and edge cases such as malformed or nested variables. Integrate with the backend or editor logic as appropriate.",
            "status": "pending",
            "testStrategy": "Test extraction with various HTML samples, including edge cases (nested, malformed, missing braces). Verify all expected variables are detected."
          },
          {
            "id": 2,
            "title": "Update EmailTemplate.variables and Display in UI",
            "description": "Synchronize extracted variables with the EmailTemplate.variables property and ensure they are displayed in the user interface.",
            "dependencies": [
              1
            ],
            "details": "On save or edit, update the EmailTemplate.variables array with the latest extracted variables. Implement UI components to show the current list of variables to the user, ensuring real-time updates as the template changes.",
            "status": "pending",
            "testStrategy": "Verify that EmailTemplate.variables is updated correctly after edits. Check that the UI reflects the current variable list and updates in real time."
          },
          {
            "id": 3,
            "title": "Implement Warning System for Variable Removal During AI Edits",
            "description": "Detect and warn users if variables are removed from the template during AI-assisted editing.",
            "dependencies": [
              2
            ],
            "details": "Compare the previous and current sets of variables after AI edits. If any variables are removed, trigger a warning in the UI to inform the user. Ensure warnings are clear and actionable, and do not block workflow unless required.",
            "status": "pending",
            "testStrategy": "Simulate AI edits that remove variables and verify that warnings are displayed. Test with multiple scenarios, including partial and complete variable removal."
          }
        ]
      },
      {
        "id": 75,
        "title": "Optimize Performance: Debouncing, Caching, and Editor Responsiveness",
        "description": "Add debounced AI requests, request cancellation, and optimize editor/preview performance for large templates. Tags: ai-email, performance, optimization, phase-3",
        "status": "pending",
        "dependencies": [
          73
        ],
        "priority": "medium",
        "details": "- Use useDebouncedCallback (e.g., from use-debounce v9.x) for 500ms debounce on AI requests.\n- Implement request cancellation using AbortController.\n- Add loading skeletons and optimize Monaco re-renders.\n- Research: React 18+ supports concurrent rendering; use memoization for large props.\n\nThis is a phase-3 performance optimization task focusing on AI email generation efficiency, editor responsiveness, and caching strategies for improved user experience.",
        "testStrategy": "Profile AI request frequency, test cancellation, and measure editor/preview render times with 50KB+ HTML. Include performance profiling to validate optimization improvements for AI email workflows.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Debounced AI Requests with Request Cancellation",
            "description": "Integrate debouncing for AI requests using useDebouncedCallback (500ms delay) and ensure requests can be cancelled using AbortController.",
            "dependencies": [],
            "details": "Use useDebouncedCallback from use-debounce v9.x to wrap AI request triggers, ensuring requests are only sent after 500ms of inactivity. Integrate AbortController to cancel any in-flight requests when a new debounced request is initiated, preventing race conditions and unnecessary processing.",
            "status": "pending",
            "testStrategy": "Simulate rapid input changes and verify that only the final AI request is sent after 500ms. Confirm that previous requests are cancelled and do not update state after cancellation."
          },
          {
            "id": 2,
            "title": "Optimize Editor and Preview Rendering for Large Templates",
            "description": "Improve the performance of the Monaco editor and preview pane when handling large HTML templates (50KB+), minimizing unnecessary re-renders.",
            "dependencies": [
              1
            ],
            "details": "Profile the editor and preview components to identify bottlenecks. Use React.memo and memoization for large props, and leverage React 18+ concurrent rendering features. Add loading skeletons to provide feedback during heavy operations. Optimize Monaco Editor configuration to reduce re-renders, such as by debouncing onChange events and virtualizing content where possible.",
            "status": "pending",
            "testStrategy": "Load and edit large (50KB+) HTML templates, measuring render times and responsiveness. Verify that UI remains responsive and that loading skeletons appear during processing."
          },
          {
            "id": 3,
            "title": "Implement Caching for AI Responses and Editor State",
            "description": "Add caching mechanisms for AI responses and editor state to reduce redundant computations and improve perceived performance.",
            "dependencies": [
              1,
              2
            ],
            "details": "Cache AI responses based on input parameters to avoid repeated requests for the same input. Use in-memory or local storage caching as appropriate. For the editor, cache state such as cursor position and scroll to restore quickly after re-renders or navigation.",
            "status": "pending",
            "testStrategy": "Test repeated AI requests with identical inputs to ensure cached responses are used. Verify that editor state is preserved and restored efficiently after navigation or reload."
          }
        ]
      },
      {
        "id": "76",
        "title": "Comprehensive Testing and Validation for Phase 1 & 2",
        "description": "Write and execute unit, integration, and E2E tests for all core and AI features, including security and performance checks. Tags: ai-email, testing, validation, phase-4",
        "status": "pending",
        "dependencies": [
          74,
          75
        ],
        "priority": "high",
        "details": "- Use Jest or Vitest for unit/integration tests; Playwright or Cypress for E2E.\n- Test CRUD, editor, preview, AI assist, variable management, and error handling.\n- Include XSS and prompt injection tests.\n- Research: Playwright v1.45+ is recommended for modern React/Next.js apps.\n- Tags: ai-email, testing, validation, phase-4",
        "testStrategy": "Run all test suites and ensure >95% coverage. Manually test edge cases and security vectors.",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop and Review Unit & Integration Test Suites for Core and AI Features",
            "description": "Create comprehensive unit and integration tests for all core and AI functionalities, ensuring coverage of CRUD, editor, preview, AI assist, variable management, and error handling.",
            "dependencies": [],
            "details": "Use Jest or Vitest to write and review test cases for each module and feature. Ensure tests cover normal, edge, and error scenarios. Validate that all business logic and data flows are tested, including AI assist and variable management. Peer review test cases for completeness and clarity.",
            "status": "pending",
            "testStrategy": "Run all unit and integration test suites, measure coverage (>95%), and manually verify edge cases."
          },
          {
            "id": 2,
            "title": "Implement and Execute End-to-End (E2E) Tests Including Security and Performance Checks",
            "description": "Design and run E2E tests for user flows, including security (XSS, prompt injection) and performance validation, using Playwright v1.45+ or Cypress.",
            "dependencies": [
              1
            ],
            "details": "Set up Playwright or Cypress for E2E testing. Automate key user journeys: CRUD, editor, preview, AI assist, and error handling. Integrate security tests for XSS and prompt injection. Include performance checks for critical flows. Validate tests against modern React/Next.js environments.",
            "status": "pending",
            "testStrategy": "Automate E2E scenarios, run security scripts, and benchmark performance. Review logs for failures and anomalies."
          },
          {
            "id": 3,
            "title": "Test Reporting, Coverage Analysis, and Validation of Release Readiness",
            "description": "Aggregate test results, analyze coverage, document defects, and confirm readiness for release based on test outcomes.",
            "dependencies": [
              2
            ],
            "details": "Collect results from all test suites. Use coverage tools to ensure >95% coverage. Document any defects and retest after fixes. Prepare a release readiness report summarizing test execution, coverage, and unresolved issues. Share findings with stakeholders for approval.",
            "status": "pending",
            "testStrategy": "Generate automated and manual test reports, validate coverage metrics, and conduct final review with QA and stakeholders."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-07T04:57:21.145Z",
      "updated": "2025-10-30T20:57:35.908Z",
      "description": "Tasks for master context"
    }
  }
}